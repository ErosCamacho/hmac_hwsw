/******************************************************************************/
/*
 *  IMSE.CNM_SPIRS-HwSec_puf4r4_2.2: puf_keygen.c for PUF4R4_2.2  32/64-bits
 *
 *  Created on: 07/09/2023
 *      Author: santiago@imse-cnm.csic.es
 *
 *  Function:
 *   - Generates a k-bit key from an identifier associated with the PUF itself 
 *     or randomly generated by it operating as a source of entropy. In both 
 *     cases, it is checked if the enrollment process has been carried out for 
 *     the key length, repetition code and configuration selected when invoking 
 *     the command (i.e., that the files containing Helper Data (_HD), challenge  
 *     mask (_CM), reference output (_RO), and PUF internal Key (_KEY) exist -- 
 *     the latter two only for debugging purposes).
 *     - If any of the files is missing or you want to generate a temporary key
 *     from a random ID, an enrollment process is carried out using the number 
 *     of tests indicated by the user to obtain the Helper Data, the Challenges 
 *     Selection Mask and the PUF Reference Output.
 *    - Invokes the PUF [repeatedly] and recovers the key to verify reliability 
 *     of the PUF as a (fixed- or random-)ID generator using the chosen 
 *	   configuration.
 *
 *  Outputs:
 *   - DBG = 0 --> No. of times the reliability test passes or fails in each run 
 *                 + HDintra values in the enrollment process and after applying  
 *                   the challenge selection mechanism
 *   - DBG = 1 --> + Main steps of the [enrollment and] key recovery process
 *                 + Initial, verified and recovered key for each PUF invocation
 *   - DBG = 2 --> + Helper Data, Challenges Selection Mask and Recovered Keys  
 *   - DBG = 3 --> + Other internal data
 * 
 *   Control:
 *     -i --> Generates a Key from a random ID provided by the PUF
 *     -w --> Wait the specified time between successive runs
 *     -e --> Wait for Enter key to be pressed between successive runs
 *
 *   Output Files:
 *   
 *          SPIRS_RoT_<board_ID>_<puf>_<t_code>_<k_length>_<rep_code>_XX.txt
 *
*/
/******************************************************************************/

/******************************** Include Files *******************************/

#include "puf4r4.h"
#include "testsystem.h"

/******************************** Test parameters *****************************/

int N_CMPS     = 512;      // -c Number of comparisons
int E_CMPS     = 51;       //    Number of discarded comparisons
int SD         = 1;        // -s Same/different LUTs													
int BG         = 1;        // -g Binary/Gray counters
int NR         = 0;        // -n Nearby/Remote RO pairs
int LH         = 0;        // -l Lower/Higher Bits
int K_bits     = 256;      // -k Number of bits of KEY  -- 128
int RC         = 7;        // -p ECC Repetition code
int E_tests    = 100;      // -m Number of test for enrollment
int N_tests    = 100;      // -t Number of test for each run
int N_runs     = 5;        // -r Number of runs
int DBG        = 0;        // -d Debug level
int RID        = 0;        // -i Random ID
int W_TIME     = 0;        // -w Wait Time between runs
int W_CHAR     = 0;		   // -e Wait Enter Key between runs
char * BOARD   = "01";     // -b Board ID										 

int PE         = 1;        // PUF/Entropy Source
char * T_code  = "---";    // Test code
char * T_board;            // Board ID

char * KEY = "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF";

/******************************************************************************/
/******************************************************************************/


int main(int argc, char** argv) {

   MMIO_WINDOW puf;
  
   int puf_ref[MN_CMPS];
   int puf_selm[MN_CMPS];
   int puf_eref[MN_CMPS];					 
   int cr; 

   int board;			 
   int triesr;
   int last_reg;
   
   int N_regs;
   int N_bits;
   int diffs;
   int sum_diffs;
   int failed_t;
   int passed_t;
   int t_passed;
   float tt;			
   unsigned long long toc, tr, ts;
 
 #if defined(AXI64)
   long long op;
   unsigned long long puf_output[MN_REGS/2];
   long long puf_selr[(int)ceil((MN_CMPS/64.))];
 #else	
   int op;
   unsigned int puf_output[MN_REGS];
   int puf_selr[(int)ceil((MN_CMPS/32.))];
 #endif
   
   unsigned int PUF_CONFIG;
   unsigned int RID_CONFIG;
   int  puf_outc[MN_CMPS];
   
   HammDist HDintra;
     
 #if defined(PYNQ)
   char * bitstream_file;
   char input_file[100];
 #endif   
 
   // char idtrail[20], odtrail[20];
   char cboard[3];		  
   char ctcode[4];   
   char key_length[5];   
   char rep_code[3];   
   char puf_refb[MN_BITS];
   char puf_erefb[MN_BITS];					 
   char puf_outb[MN_BITS];
   
   char keyb[ML_KEY];
   int  keyc[ML_KEY/4];
   char Ext_Keyb[MN_BITS];
   char Help_Datb[MN_BITS];
   int  Help_Datc[MN_BITS/4];

   char Ext_Rkeyb[MN_BITS];
   char Rec_keyb[ML_KEY];
   int  Rec_keyc[ML_KEY/4];

 #if !defined(STANDALONE)

   FILE * HD_ptr;	// PUF Helper Data
   FILE * CM_ptr;	// PUF Challenges Mask
   FILE * RO_ptr;	// PUF Reference Output
   //FILE * Key_ptr;  // Secret Key
 
   char output_file[100];
   char HelperData_file[100];
   char ChallengesMask_file[100];
   char ReferenceOutput_file[100];
   char SecretKey_file[100];
   int  MakeEnrollment;
 
   int arg;
   for(arg=1; arg < argc; arg++) {
      if(argv[arg][0] == '-') {
         if(argv[arg][1] == 'h') {
            printf("\n Usage: puf_keygen [ -h | [-g] [-n] [-l] [-i] [-e] [-k <n_bits>] [-c <n_cmpc>]");
            printf("\n                   [-p <ecc_repcode>] [-m <n_tests>] [-t <n_tests>] [-r <n_runs>]");
 			printf("\n                   [-d <dbg_level>] [-w <w_time>] ]\n\n");
           return 0;   
         } else if(argv[arg][1] == 'b') { 
            if(arg<argc-1) {
               board = atoi(argv[arg+1]);
               sprintf(cboard, "%02d", board);
               BOARD = cboard;          
            }
         } else if(argv[arg][1] == 'd') { 
            if(arg<argc-1) DBG = atoi(argv[arg+1]);
         } else if(argv[arg][1] == 'c') {
            if(arg<argc-1) N_CMPS = atoi(argv[arg+1]);
            if(N_CMPS>MN_CMPS) N_CMPS=MN_CMPS;
            if(N_CMPS<8) N_CMPS=8;
         } else if(argv[arg][1] == 't') {
            if(arg<argc-1) N_tests = atoi(argv[arg+1]);
            if(N_tests<1) N_tests=1;
         } else if(argv[arg][1] == 'm') {
            if(arg<argc-1) E_tests = atoi(argv[arg+1]);
            if(E_tests>MN_TESTS) E_tests=MN_TESTS;
            if(E_tests<10) E_tests=10;
         } else if(argv[arg][1] == 'r') {
            if(arg<argc-1) N_runs = atoi(argv[arg+1]);
            if(N_runs<1) N_runs=1;
         } else if(argv[arg][1] == 'k') {
            if(arg<argc-1)K_bits = atoi(argv[arg+1]);
			if(K_bits>ML_KEY) K_bits=ML_KEY;
         } else if(argv[arg][1] == 'p') {
            if(arg<argc-1) RC = atoi(argv[arg+1]);
            if(RC==(RC/2)*2) { RC = 5;
               printf("\n\n --> RC must be odd. Set to %2d.\n\n", RC);}
         } else if(argv[arg][1] == 'w') {
            if(arg<argc-1) W_TIME = atoi(argv[arg+1]);
         } else if(argv[arg][1] == 'g') {
            BG=0;
         } else if(argv[arg][1] == 'n') {
            NR=1;
         } else if(argv[arg][1] == 'l') {
            LH=1;
         // } else if(argv[arg][1] == 's') {
            // SD=1;				
         } else if(argv[arg][1] == 'e') {
            W_CHAR=1;
         } else if(argv[arg][1] == 'i') {
            RID=1;
         } else {
            printf("\n unknown option: %s\n\n", argv[arg]);
            return ERROR;
         }
      }   
   } 
   
 #endif

   if (PE == 0) {
      T_code = "ES";
   } else {
      sprintf(ctcode, "%01d%01d%01d", BG, NR, LH);
      T_code = ctcode;
   }
 
    T_board = BOARD;
	if (strcmp(T_board, "00") == 0) {
      printf("\nBoard ID: ");
      scanf("%d", &board);
      sprintf(cboard, "%02d", board);
      T_board = cboard;
   }

   sprintf(key_length, "%d", K_bits);
   sprintf(rep_code, "%d", RC);
  
   // sprintf(idtrail, "_%d_%d_%d", Nx*Ny, Ns, Nbc);
  
   // Calculate No. of challenges that can be discarded (E_CMPS)
   
   N_bits = ceil(RC * K_bits/4.)*4;         // Number of bits 
   if (N_bits/4 > N_CMPS) {
	  printf("\n  %d comparisons are not enough to obfuscate a %d-bit key with a repetition code of length %d.  Bye ...\n\n", N_CMPS, K_bits, RC);
	  return ERROR;
   } else {
      E_CMPS = N_CMPS - N_bits/4;           // Number of discarded comparisons
   }
   
 #if defined(AXI64)
   N_regs = ceil((N_CMPS-E_CMPS)/16.);     	// Number of registers 
 #else
   N_regs = ceil((N_CMPS-E_CMPS)/8.);     	// Number of registers 
 #endif

   // Start Test

   printf("\n  --- Start Test ---> T_code %s, K_bits %d, RC %d, N_cmps %d, E_cmps %d\n",
                                   T_code, K_bits, RC, N_CMPS, E_CMPS);							   
   printf(" 		      E_tests %d, N_tests %d, N_runs %d\n",
                          E_tests, N_tests,  N_runs);
 
 #if defined(PYNQ)
   strcpy(input_file, InF);
   // strcat(input_file, idtrail);
   bitstream_file = strcat(input_file, ".bit");
   if (DBG > 0) {
      printf("\n   ---  Load Bitstream file: %s\n", bitstream_file);
   } else {
      printf("\n");
   }
   // Load Bitstream
   PUF_loadBitstream(bitstream_file, DBG+2);
 #endif
 
   if (DBG > 0) {
      printf("\n");
   }
 
   PUF_CONFIG = (PE<<6) +( SD<<5) + (BG<<4) + (NR<<3) + (LH<<2);
   RID_CONFIG = (BG<<4) + (NR<<3) + (LH<<2);

   // For each PUF instance (s)
   int ns = sizeof(opt)/sizeof(opt[0]);
   for (int s=0; s<ns; s++) {

      // Create PUF interface
      PUF_createMMIOWindow(&puf, PUF_BASEADDR[s], PUF_LENGTH, 0); 	   
	   
	  strcpy(output_file, OutF);  
      // strcat(output_file, odtrail);
      strcat(output_file, "_");     
      strcat(output_file, T_board);
      strcat(output_file, "_");     
      strcat(output_file, opt[s]);
      strcat(output_file, "_");     
      strcat(output_file, T_code);
	  strcat(output_file, "_");     
	  strcat(output_file, key_length);
	  strcat(output_file, "_");     
	  strcat(output_file, rep_code);
	  
	  strcpy(HelperData_file, output_file);  	
	  strcat(HelperData_file, "_HD.txt");
	  strcpy(ChallengesMask_file, output_file);  	
	  strcat(ChallengesMask_file, "_CM.txt");
	  strcpy(ReferenceOutput_file, output_file);  	
	  strcat(ReferenceOutput_file, "_RO.txt");
	  strcpy(SecretKey_file, output_file);  	
	  strcat(SecretKey_file, "_KEY.txt");
	  
      printf("\n");
	  if (DBG > 1) {
	     printf("\n        - HelperData_file:      %s", HelperData_file);
		 printf("\n        - ChallengesMask_file:  %s", ChallengesMask_file);
		 printf("\n        - ReferenceOutput_file: %s", ReferenceOutput_file);
		 // printf("\n        - SecretKey:            %s", SecretKey_file);
		 printf("\n");
	  }

      MakeEnrollment = 0;
	  if (!(HD_ptr = fopen(HelperData_file, "r"))) {
		 MakeEnrollment = 1;
		 HD_ptr = fopen(HelperData_file,"w");  
		 if (DBG > 0) printf("\n        - HelperData_file not found. Creating it ...\n");
	  }

	  if (!(CM_ptr = fopen(ChallengesMask_file, "r"))) {
		 MakeEnrollment = 1;
		 CM_ptr = fopen(ChallengesMask_file,"w");  
		 if (DBG > 0) printf("        - ChallengesMask_file not found. Creating it ...\n");
	  }

	  if (!(RO_ptr = fopen(ReferenceOutput_file, "r"))) {
		 MakeEnrollment = 1;
		 RO_ptr = fopen(ReferenceOutput_file,"w");  
		 if (DBG > 0) printf("        - ReferenceOutput_file not found. Creating it ...\n");
	  }

	  // if (!(Key_ptr = fopen(SecretKey_file, "r"))) {
		 // MakeEnrollment = 1;
		 // if (DBG > 0) 
		 // Key_ptr = fopen(SecretKey_file,"w");  
		 // if (DBG > 0) printf("        - SecretKey_file not found. Creating it ...\n");
	  // }

      // Reset Challenges Mask
	  op = 0;
      writeMMIO(&puf, &op, CHLADDC, sizeof(op));	 

	  ts = Wtime();
      // for (int c=0; c<ceil(N_CMPS/(Dbw/4.))*16; c++) {
     	 // puf_selm[c] = 0;
      // }
      for (int c=0; c<MN_CMPS; c++) {
     	 puf_selm[c] = 0;
		 Help_Datc[c] = 0;
		 puf_ref[c] = 0;
		 puf_eref[c] = 0;
      }
	  
  #if defined(AXI64)
      for (int r=0; r<(int)ceil((MN_CMPS/64.)); r++) {
  #else
      for (int r=0; r<(int)ceil((MN_CMPS/32.)); r++) {
  #endif
     	 puf_selr[r] = 0;
      }
	  
      if (MakeEnrollment || RID) {     //   Make enrollment or read files

         if (DBG > 0) {
            printf("\n      - Making PUF Enrollment\n");
         }
         // Perform the enrollment process 	    
         tr = Wtime(); 
         HDintra = PUF_enrollment(&puf, 0, 1, PUF_CONFIG, E_tests, N_CMPS, E_CMPS, puf_ref, puf_selm);                        	
         toc = Wtime() - tr;
	  	  
	     if (DBG > 0) {
            printf("\n        - Getting Challenges Mask");
		 } else {
            printf("\n     ");
		 }
		 printf("  ---  HDintra: %6.3f [%5.3f - %5.3f] (W/o enrollment)", HDintra.mean, HDintra.min, HDintra.max);
	     if (DBG > 0) {
	        printf("  (%.3f s)\n", toc/1000000.);
	     }
	  
	     // Get PUF reference output for N_CMPS-E_CMPS
 	     cr = 0;
         for (int c=0; c<N_CMPS; c++) {
    	    if (puf_selm[c] == 0) {
		       puf_eref[cr] = puf_ref[c];
		       cr++;
		    }
         }

         chl_btor(puf_selm, N_CMPS, puf_selr);

         // Write Challenges Selection Mask
	     if (DBG > 0) {
            printf("        - Writing Challenges Mask");
		 } else {
            printf("\n     ");
         }
  #if defined(AXI64)
         PUF_writeChallegesMask(&puf, puf_selr, ceil(MN_CMPS/64.), 0); 
  #else
         PUF_writeChallegesMask(&puf, puf_selr, ceil(MN_CMPS/32.), 0); 
  #endif
         op = RCHL;										  
         writeMMIO(&puf, &op, CHLADDC, sizeof(op));	 
		  
         tr = Wtime(); 
	     HDintra = PUF_HD(&puf, 1, PUF_CONFIG, puf_eref, puf_selm, E_tests, N_CMPS, E_CMPS);
	     printf("  ---  HDintra:  %5.3f [%5.3f - %5.3f] (W enrollment)", HDintra.mean, HDintra.min, HDintra.max);
         toc = Wtime() - tr;
	     if (DBG > 0) {	 
            printf("  (%.3f s)\n", toc/1000000.);
		 } else {
            printf("\n       ");
		 }

  		 // Show PUF Reference Output (used to get the Challenges Mask)
         if (DBG > 2) {
	        printf("\n\n              puf_ref: ");    
            for (int c=0; c<N_CMPS; c++) {
               printf("%1X", puf_ref[c]);
			   if (c%64 == 63) printf("\n                       "); 
            }
         }	
 
		 // Write ChallengesMask_file
         for (int c=0; c<N_CMPS; c++) {
             fprintf(CM_ptr, "%1X", puf_selm[c]);
	     }
		 fclose(CM_ptr);
		 
         if (DBG > 0) printf("\n        - Writing Challenges Mask file");
         if (DBG > 1) {	 
   	        printf("\n\n             puf_selm: ");    
            for (int c=0; c<N_CMPS; c++) {
               printf("%1X", puf_selm[c]);
			   if (c%64 == 63) printf("\n                       "); 
	        }
	        printf("\n");    
   	     }

 		 // Write ReferenceOutput_file
         for (int c=0; c<(N_CMPS-E_CMPS); c++) {
            fprintf(RO_ptr, "%1X", puf_eref[c]);
         }
		 fclose(RO_ptr);
		 
         if (DBG > 0) printf("\n        - Writing Reference Output file");
         if (DBG > 1) {
	        printf("\n\n             puf_eref: ");    
            for (int c=0; c<(N_CMPS-E_CMPS); c++) {
               printf("%1X", puf_eref[c]);
			   if (c%64 == 63) printf("\n                       "); 
            }
	        printf("\n");    
		 }
      }               //  end MakeEnrollment  
	     else 
	  {               //  read from files 
        
         char  bufer[MN_CMPS+1];         

         //  read PUF Reference Output from files
         if (DBG > 1) printf("\n        - Reading PUF Reference Output file");
         if (DBG > 2) printf("\n\n             puf_eref: ");
		 
         fgets(bufer, N_CMPS-E_CMPS+1, RO_ptr);
         for (int c=0; c<N_CMPS-E_CMPS; c++) {
			sscanf(&bufer[c], "%1X", &puf_eref[c]);
			if (DBG > 2) {	
			   printf("%X", puf_eref[c]); 
			   if (c%64 == 63) printf("\n                       "); 
			}
		 }
		 //printf("\n");

         //  read Helper Data from files
         if (DBG > 0) printf("\n        - Reading Helper Data file");
         if (DBG > 1) printf("\n\n             Help_Dat: "); 
		 
         fgets(bufer, N_CMPS+1, HD_ptr);
         for (int c=0; c<(K_bits*RC)/4; c++) {	 
			sscanf(&bufer[c], "%1X", &Help_Datc[c]);
			if (DBG > 1) {	
               printf("%X", Help_Datc[c]); 
			   if (c%64 == 63) printf("\n                       "); 
			}
	     }
		 //printf("\n");

         //  read Challenge Mask from files
         if (DBG > 0) printf("\n        - Reading Challenges Mask file");
         if (DBG > 1) printf("\n\n             puf_selm: ");
		 
         fgets(bufer, N_CMPS+1, CM_ptr);
		 for (int c=0; c<N_CMPS; c++) {
			sscanf(&bufer[c], "%1X", &puf_selm[c]);
			if (DBG > 1) {	
               printf("%X", puf_selm[c]); 
			   if (c%64 == 63) printf("\n                       "); 
			}
	     }
		 //printf("\n");
		
         chl_btor(puf_selm, N_CMPS, puf_selr);

         // Write Challenges Selection Mask
	     if (DBG > 0) {
			printf("\n        - Writing CS Mask ");
         }
  #if defined(AXI64)
         PUF_writeChallegesMask(&puf, puf_selr, ceil(MN_CMPS/64.), 0); 
  #else
         PUF_writeChallegesMask(&puf, puf_selr, ceil(MN_CMPS/32.), 0); 
  #endif
         op = RCHL;										  
         writeMMIO(&puf, &op, CHLADDC, sizeof(op));	 

      }  //  end make enrollment or read files
	  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if(RID) {  // Get random ID
	     
         if (DBG > 0) printf("\n        - Generating random ID ");
         if (DBG > 0) printf("\n\n                  Key: "); 

         // Generate PUF response
         last_reg = PUF_applyChallenges(&puf, RID_CONFIG, N_CMPS-E_CMPS, 0);
            
         if (last_reg < ceil((float)(N_CMPS-E_CMPS)/Dbw)) {
            triesr++;
		    if (triesr > 100) {
		       printf("\n\n Max tryes reached. Bye ...\n\n");
		       exit(ERROR);
 		    }
         } else {
            
            //Read PUF results
            PUF_readOutput(&puf, N_CMPS-E_CMPS, puf_output, 0);
                               
            // convert to hexadecimal    
	        puf_rtoc(puf_output, N_regs, puf_outc);
            for (int c=0; c<K_bits/4; c++) {
               keyc[c] = puf_outc[c];
	           if (DBG > 0) {
                  printf("%X", keyc[c]); 
                  if (c%64 == 63) printf("\n                       "); 
               }
            } 
		 }

      } else {  // Read Key from source code
	        
         if (DBG > 0) printf("\n        - Getting Key from source code");
         if (DBG > 0) printf("\n\n                  Key: "); 
	  
         for (int c=0; c<K_bits/4; c++) {
            sscanf(&KEY[c], "%1X", &keyc[c]);
	        if (DBG > 0) {
               printf("%X", keyc[c]); 
               if (c%64 == 63) printf("\n                       "); 
            }
         }
      }

      puf_ctob(puf_eref, N_CMPS-E_CMPS, puf_refb);
      puf_ctob(keyc, K_bits, keyb);

      if (DBG > 2) {	   
 	     printf("\n                  key: ");    
         for (int b=0; b<K_bits; b++) {
            printf("%X", keyb[b]); 
            if (b%64 == 63) printf("\n                       "); 
         }
      }

      // Calculate Extended Key
      int kb = 0;
      for (int i=0; i<K_bits; i++) {
         for (int j=0; j<RC; j++) {
            kb = i * RC + j;
            Ext_Keyb[kb] = keyb[i];
         }
      }

      if (DBG > 2) {	   
 	     printf("\n              Ext_Key: ");    
         for (int b=0; b<K_bits*RC; b++) {
            printf("%X", Ext_Keyb[b]); 
            if (b%64 == 63) printf("\n                       "); 
         }
      }

      if (MakeEnrollment || RID) {     //   Generate Helper Data

         // Generate Helper Data
         for (int b=0; b<K_bits*RC; b++) {
		    Help_Datb[b] = Ext_Keyb[b]^puf_refb[b];
         }
		 
         if (DBG > 0) printf(" \n        - Generating Helper Data");
         if (DBG > 2) {	   
    	    printf("\n\n             Help_Dat: ");    
            for (int b=0; b<K_bits*RC; b++) {	 
		       printf("%X", Help_Datb[b]); 
	           if (b%64 == 63) printf("\n                       "); 
	        }
         }
	  
         // Convert binary to hexadecimal
	     puf_btoh(Help_Datb, K_bits*RC, Help_Datc);
		 
 		 // Write HelperData_file
 		 for (int c=0; c<(K_bits*RC)/4; c++) {
            fprintf(HD_ptr, "%1X", Help_Datc[c]);
         }
		 fclose(HD_ptr);
		 
         if (DBG > 0) printf("\n        - Writing Helper Data file");
         if (DBG > 1) {	   
    	    printf("\n\n             Help_Dat: ");    
            for (int c=0; c<(K_bits*RC)/4; c++) {	 
		        printf("%X", Help_Datc[c]); 
	            if (c%64 == 63) printf("\n                       "); 
			}
         }
      }
	  
/////////////////////////////////////////////////////////////////////////////////////////

      // Verify Key recoverability
	  
      puf_ctob(Help_Datc, K_bits*RC/4, Help_Datb);
      puf_ctob(puf_eref, K_bits*RC/4, puf_erefb);

      // XOR with Helper Data
      for (int b=0; b<K_bits*RC; b++) {
         Ext_Rkeyb[b] = Help_Datb[b]^puf_erefb[b];
	  } 
	  
      if (DBG > 0) printf(" \n        - Generating Ext_Rkeyb");
      if (DBG > 2) {
	     printf("\n\n             Help_Dat: ");    
         for (int b=0; b<K_bits*RC; b++) {	 
		    printf("%X", Help_Datb[b]); 
	        if (b%64 == 63) printf("\n                       "); 
		 }
      }

      if (DBG > 2) {	   
    	 printf("\n\n            puf_erefb: ");    
         for (int b=0; b<K_bits*RC; b++) {	 
		    printf("%X", puf_erefb[b]); 
	        if (b%64 == 63) printf("\n                       "); 
	     }
      }

      if (DBG > 2) {	   
    	 printf("\n\n            Ext_Rkeyb: ");    
         for (int b=0; b<K_bits*RC; b++) {	 
		    printf("%X", Ext_Rkeyb[b]); 
	        if (b%64 == 63) printf("\n                       "); 
	     }
      }

      // Apply Error Correction Code 
      puf_ecc(Ext_Rkeyb, K_bits*RC, RC, Rec_keyb);
	   
      if (DBG > 0) printf(" \n        - Verifying Key");	  
      if (DBG > 1) {
	     printf("\n\n              Rec_key: ");    
         for (int b=0; b<K_bits; b++) {	 
            printf("%X", Rec_keyb[b]); 
            if (b%64 == 63) printf("\n                       "); 
         }
      }

      for (int c=0; c<K_bits; c++) {	 
         Rec_keyc[c] = 0;
	  }

      // Convert binary to hexadecimal
	  puf_btoh(Rec_keyb, K_bits, Rec_keyc);
	  
      if (DBG > 0) {	   
  	     printf("\n\n              Rec_key: ");    
         for (int c=0; c<K_bits/4; c++) {	 
            printf("%X", Rec_keyc[c]); 
            if (c%64 == 63) printf("\n                       "); 
	     }
      }

////////////////////////////////////////////////////////////////////////////////////////////////////////

      // Evaluate Key recoverability
	  
	  if (DBG > 0) {
           printf("\n        - Recovering Key \n");
      }
	  
	  t_passed = 0;

      // For each run
      for (int run=1; run<=N_runs; run++) {
  	  
         triesr = 0;
         sum_diffs = 0;
		 failed_t = 0;
		 passed_t = 0;
		 
         tr = Wtime();
         
         if (N_runs > 1) printf("\n          - Run %4d   --- ", run);
         if (DBG > 0) printf("\n\n");

         // For each Test (t)
		 int t = 0;
         for (t=1; t<=N_tests; t++) {
            
            // Generate PUF response
            last_reg = PUF_applyChallenges(&puf, PUF_CONFIG, N_CMPS-E_CMPS, 0);
            
            if (last_reg < ceil((float)(N_CMPS-E_CMPS)/Dbw)) {
               triesr++;
               t = t-1;
            } else {
            
               //Read PUF results
               PUF_readOutput(&puf, N_CMPS-E_CMPS, puf_output, 0);
                               
               // Get PUF comparisons      
	           puf_rtoc(puf_output, N_regs, puf_outc);
	         	         
               // Get PUF bits      
               puf_ctob(puf_outc, N_CMPS-E_CMPS, puf_outb);

               // XOR with Helper Data
			   for (int b=0; b<K_bits*RC; b++) {
                  Ext_Rkeyb[b] = Help_Datb[b]^puf_outb[b];
	           }         

               // Apply Error Correction Code 
               puf_ecc(Ext_Rkeyb, K_bits*RC, RC, Rec_keyb);
			   
               if (DBG > 2) {	   
          	      printf("\n              Rec_key: ");    
                  for (int b=0; b<K_bits; b++) {	 
                     printf("%X", Rec_keyb[b]); 
                     if (b%64 == 63) printf("\n                       "); 
         	      }
		          printf("\n");
               } 

		       for (int h=0; h<ML_KEY/4; h++) {
		          Rec_keyc[h] = 0;
		       }

               // Convert binary to hexadecimal
	           puf_btoh(Rec_keyb, K_bits, Rec_keyc);
			   
               if (DBG > 0) {	   
          	      printf("              Rec_key: ");    
                  for (int c=0; c<K_bits/4; c++) {	 
                     printf("%X", Rec_keyc[c]); 
                     if (c%64 == 63) printf("\n                       "); 
         	      }
		          printf("\n");
               }

               // Compare with the original Key             

               diffs = 0;
			   for (int b=0; b<K_bits; b++) {
                  if (Rec_keyb[b] != keyb[b]) {
                     diffs++;
                  }
			   }
			   
			   if (diffs == 0) {
			      passed_t++;
               } else {
                  failed_t++;
			   }
			   			   
               sum_diffs = sum_diffs + diffs;
			   
           }
			
         }  // end tests

         if (DBG > 0) printf("\n                       --- ");
         printf(" #tests passed %6d/%d", passed_t, N_tests);
		 	 
         if(sum_diffs == 0) {
            printf(" \t-->  Passed");
         } else {
            printf(" \t-->  Failed");
         }      
		 toc = Wtime() - tr;                     // Run time
         printf("\t(%.3f s)", toc/1000000.);
		 
         t_passed = t_passed + passed_t;	
		          
      }  //end runs

	  if (N_runs > 1) {
		 printf("\n\n          - Total      ---  #tests passed %6d/%d \t--> ", t_passed, N_tests*N_runs);
		 if(t_passed == N_tests*N_runs) {
            printf(" PASSED  ");
		 } else {
            printf(" FAILED  ");
		 }			 
	  }		 

      toc = Wtime() - ts;
      printf("\t(%.3f s)", toc/1000000.);
      tt = tt + toc;

      if (W_TIME != 0) sleep(W_TIME);
	  if (W_CHAR == 1) getchar();		 
         
      printf("\n\n");	
	  
  #if !defined(STANDALONE)
         //Close PUF interface
         int Status;
         Status = closeMMIOWindow(&puf);
         if (Status != SUCCESS) {
            printf(" Failed !!!\n");
            return 1;
         }
  #endif
	  
   }  // end pufs
     
   printf("  --- End Test");
   printf("  (%.3f s)\n\n", tt/1000000.);
   
}
  


